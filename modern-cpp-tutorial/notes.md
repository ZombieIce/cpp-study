## Chapter 1
在编写C++时，应该尽可能的避免使用诸如void*之类的程序风格。而不得不使用C时，应该注意使用extern "C" 这种特性，将C语言的代码与C++代码进行分离编译，再统一链接这种做法。
## Chapter 2
#### 2.1 常量
- nullptr 出现的目的是为了替代NULL。
- constexpr 如果编译器能够在编译时把表达式直接优化并植入到程序运行时，将能增加程序的性能。
  ```c++
  const int len_2 = len + 1;
  char arr_4[len_2];
  ```
  C++标准中数组的长度必须是一个常量表达式，而对于 len_2 而言，这是一个const常数，而不是一个常量表达式，因此它是一个非法的行为。
  C++11提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这是关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该时一个常量表达式。此外 constexpr 修饰的函数可以使用递归。
#### 2.2 变量及其初始化
- C++17可以在if else 中初始化
- 初始化列表
  在传统C++中，不同的对象有着不同的初始化方法。普通数组、POD类型都可以使用{}进行初始化，也就是初始化列表。对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用()进行。这些不同方法都针对各自对象，不能通用。
- 结构化绑定
  结构化绑定提供了类似其他语言中提供的多返回值的功能。
#### 2.3 类型推导
C++11引入了auto和decltype这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得C++也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。
- auto C++20起，auto甚至能用于函数传参
- decltype 为了解决 auto 关键字只能对变量进行类型推到的缺陷而出现的。用法和typeof相似
- 尾返回类型推导 C++11还引入了一个叫做尾返回类型，利用auto关键字将返回类型后置，C++14开始是可以直接让普通函数具备返回值推导
- decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的制定decltype的参数表达式
#### 2.4 控制流
- if constexpr C++17 将 constexpr 这个关键字引入到if语句中，允许在代码中声明场量表达式的判断条件。
- C++11 引入了基于范围的迭代写法
#### 2.5 模板
- 递归模板函数
- 变量模板展开 C++17中增加了变参模板展开的支持
#### 2.6 面向对象
- 委托构造 C++11引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的。
- 继承构造 C++11利用关键字using引入了继承构造函数的概念
- override 当重载虚函数时，引入override关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译。
- final 是为了防止类被继续继承以及终止虚函数继续重载引入的
- 显式禁用默认函数
  ```c++
  class Magic{
    public:
        Magic() = default;
        Magic& operator=(const Magic&) = delete;
        Magic(int magic_number);
  }
  ```
- 强类型枚举
  ```c++
  enum class new_enums: unsigned int {
    value1,
    value2,
    value3 = 100,
    value4 = 100
  };

  if (new_enums::value3 == new_enums::value4) {
    std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
  }

  ```
## Chapter 3
#### 3.1 Lambda 表达式
Lambda表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。基本语法如下：
\[捕捉列表\]\(参数列表\)mutable\(可选\) 异常属性 -> 返回类型{
  // 函数体
}
- 值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，而非调用时才拷贝
- 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化
- 隐式捕获 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获.
- 表达式捕获 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的
- 泛型 Lambda 从 C++14 开始，Lambda 函数的形式参 数可以使用 auto 关键字来产生意义上的泛型
常用的四种形式可以是：
- [] 空捕获列表
- \[name1, name2, ...\] 捕获一系列变量
- \[&\]引用捕获，让编译器自行推导引用列表
- \[=\]值捕获，让编译器自行推导值捕获列表
#### 3.2 函数对象包装器
- std::function Lambda表达式的本质是一个和函数对象类型相似的类类型的对象，当Lambda表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递。C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进 行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹(相对来说，函数 指针的调用不是类型安全的)，换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。
- std::bind 和 std::placeholder 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次 性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一 个新的对象，然后在参数齐全后，完成调用。
#### 3.3 右值引用
右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大 量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。
- 左值 (lvalue, left value) 顾名思义就是赋值符号左边的值。准确来说，左值是表达式(不一定是赋 值表达式)后依然存在的持久对象。
- 右值 (rvalue, right value) 右边的值，是指表达式结束后就不再存在的临时对象。
- 纯右值 (prvalue, pure rvalue) 纯粹的右值，要么是纯粹的字面量，例如 10, true;要么是求值结 果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始 字面量、Lambda 表达式都属于纯右值。需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。
- 将亡值 即将被销毁、却能够被移动的值
1. 右值引用和左值引用
要拿到一个将亡值，就需要用到右值引用:T &&，其中 T 是类型。右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获 得一个右值临时对象。
2. 移动语义
传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。右值 引用的出现恰好就解决了这两个概念的混淆问题。
3. 完美转发 一个声明的右值引用其实是一个左值。模板函数中使用 T&& 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为
右引用类型。这才使得 v 作为左值的成功传递。
## Chapter 4 
#### 4.1 线性容器
std::array 与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固 定的，那么可以优先考虑使用 std::array 容器。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。
#### 4.2 无序容器
传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 < 操作符比较元素大小并判断 元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 < 操作符的顺序来逐个遍历。
而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。
#### 4.3 元组
- std::make_tuple 构造元素
- std::get: 获得元组某个位置的值
- std::tie: 元组拆包
## Chapter 5 智能指针与内存管理
#### 5.1 RAII与引用计数
在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数(在 离开作用域时调用)的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。
注意:引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过 程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。
#### 5.2 std::shared_ptr
- std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的 std::shared_ptr 指针。
- std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并
通过 use_count() 来查看一个对象的引用计数。
#### 5.3 std::unique_ptr
std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全
#### 5.4 std::weak_ptr
- std::weak_ptr 是一种弱引用(相比较 而言 std::shared_ptr 就是一种强引用)。弱引用不会引起引用计数增加
- std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true; 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未 被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。
## Chapter 6 正则表达式
#### 6.2 std::regrex 及其相关
std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。
## Chapter 7 并行与并发
#### 7.1 并行基础
std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <thread> 头文件，它提供了很多基本的线程操作，例如 get_id() 来获取所创建线程的线程 ID，使用join() 来等待一个线程结束(与该线程汇合)等等
#### 7.2 互斥量与临界值
- std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其 成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。但是在实际编写代码的过程中，最好不去直 接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 std::lock_guard。RAII 在不失代码简洁性 的同时，很好的保证了代码的异常安全性。
- std::unique_lock 则 是 相 对 于 std::lock_guard 出 现 的，std::unique_lock 更 加 灵 活， std::unique_lock 的对象会以独占所有权(没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权)的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。
- std::lock_guard 不能显式的调用 lock 和 unlock，而 std::unique_lock 可以在声明后的任意位 置调用，可以缩小锁的作用范围，提供更高的并发度。
#### 7.3 Future
而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。自然地，我们很 容易能够想象到把它作为一种简单的线程同步手段，即屏障(barrier)。
#### 7.4 条件变量
条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。ondition_variable 实例被创建出现主要就是用于唤醒等 待线程从而避免死锁。std::condition_variable 的 notify_one() 用于唤醒一个线程;notify_all() 则是通知所有线程。
#### 7.5 原子操作与内存模型
在 C++11 中多线程下共享变量的读写这一问题上，还引入了 std::atomic 模板，使得我们实例化一个原子类型，将一个原子类型读写操作从一组指令，最小化到单 个 CPU 指令。当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐条件的要求，因而我们总是可以通过
std::atomic<T>::is_lock_free 来检查该原子类型是否需支持原子操作。
- 内容顺序
  为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型:
  - 宽松模型:在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间 原子操作的顺序是任意的。类型通过 std::memory_order_relaxed 指定。
  - 释放/消费模型:在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但 另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 x 的 写操作，线程 B 仅依赖其中第三次 x 的写操作，与 x 的前两次写行为无关，则当 A 主动 x.release() 时候(即使用 std::memory_order_release)，选项 std::memory_order_consume 能够确保 B 在 调用 x.load() 时候观察到 A 中第三次对 x 的写操作。
  - 在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 std::memory_order_release 和获取 std::memory_order_acquire 之间规定时序，即发生在释放 (release)操作之前的所有写操作，对其他线程的任何获取(acquire)操作都是可见的，亦即发生顺序(happens-before)。
  - 顺序一致模型:在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 std::memory_order_seq_cst 进行指定。
## chapter 9
#### 9.1 新类型
C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。
#### 9.2 noexcept的修饰和操作
使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。noexcept 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。
#### 9.3 字面量
C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时， 将原始字符串使用括号包裹
#### 9.4 内存对齐
C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。alignof 关键字 能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。当然我们有时候并不 满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 alignas 来重新修饰某个结构 的对齐方式。
## chapter 10 
#### 概念与约束
概念(Concepts)是对 C++ 模板编程的进一步增强扩展。简单来说，概念是一种编译期的特性，它 能够让编译器在编译期时对模板参数进行判断，从而大幅度增强我们在 C++ 中模板编程的体验。使用 模板进行编程时候我们经常会遇到各种令人发指的错误，这是因为到目前为止我们始终不能够对模板参 数进行检查与限制。